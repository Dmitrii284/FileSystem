#include <iostream>
#include <fstream> // Библиотека работает с файловой системой ПК с использованием Классов, Обьектов. С++
// Можно использовать 3 класса ofstrrim - Запись в файл. ifstream - чтение файлов fstream -  Запись и чтение
#include<sstream>

//Task 1 
bool statistic(std::string str) {// Прототип

}


int main() {
	setlocale(LC_ALL, "Rus");
	int n;

	

	/*std::string path = "file.txt";*/// folder; //Относительный путь к файлу, который нужно открыть 
	//Чтобы его открыть надо путь знакть И мы создадим строковую переменную и указываем путь

	// КЛАСС ofstream для чтения из файла
	/*
	// ofstream позволяет открывать файлы для добавления в них текста Если открываемого файла нет то он будет создан
	/*std::ofstream out /*(path)*/ /*; */     //Чтобы его открыть надо путь знакть И мы создадим строковую переменную и указываем путь
	/*out.open(path, std::ios::app); */
	// Открытие файла по указанному пути и в указанном режиме std::ios::app Пок он открыт то сторонние приложения не могут с ним работать
	// Открытие по умолчанию. Если файла нет то он будет создан. Что видим на фото .
	
	// Проверка файла на открытие с помощью метода .is_open()
	/*if (out.is_open()) {
		std::cout << "Файл открыт для записи\n";
		std::cout << "Введите строку -> ";
		std::string str;
		std::getline(std::cin, str); // Запись в файл
		//std::cin  Это запись из файла
		out << str<<'\n';// Добавление текста в файл ТУТ МОЖНО НАПИСАТЬ ТЕКСТ И ОН ПОЯВИТЬСЯ В ФАЙЛЕ
		// Надо добавлять разделитель чтобы новая запись добавлялась в следующую строку
		std::cout << "Запись добавлена в Файл!\n";
	}
	else
		std::cout << "Ошибка открытия файла!\n";

	out.close(); 
	*/
	//Закрытие файла и очистка обекта out 
	//всегда закрывем файл после работы над ним
	


	//ВОЗМОЖНЫЕ ПРИЧИНЫ ОШИБКИ ОТКРЫТИЯ ФАЙЛА
	//1. Файл открыт другим приложением или объектом
	//2.Неправильный синтаксис указания пути к файлу
	//3. Нет доступа к файлу (Это различные разрешения на ПК)

	

	//Класс ifstream  режим только ios::in по умолчанию и еще ios::binari

	/*std::ifstream in;
	in.open(path);
	
	// Есть 3 алгоритма как считать из файла
	if (in.is_open()){
		std::cout << "Файл открыт для считывания\n";
		std::string file; 
		*/
		//ПОСИМВОЛЬНОЕ СЧИТЫВАНИЕ
		/*char sym;
		while (in.get(sym))
			file += sym;
			std::cout << sym;
			std::cout << file;*/
		
		//ПОСЛОВНОЕ СЧИТЫВАНИЕ (для считывания ключей или одного слова, т.к все в одну кучу)  Когда слова не связанные
		
		//while (!in.eof()) {// end of file
		//	std::string str;
		//	in >> str;
		//	file += str + ' ';
		//}
		//std::cout << file;

		//	ПОСТРОЧНОЕ СЧИТЫВАНИЕ очень удобный способ возврата данных  Мы считали строку И сразу можем обработать ее
		/*std::string str;
		while (std::getline(in,str))
			file += str + '\n';
		std::cout << file;

	}
	else
		std::cout << "Ошибка открытия файла!\n";
		

	in.close();
	*/

	//1. Файл открыт другим приложением или объектом
	//2. Неправильный синтаксис указания пути к файлу
	//3. Нет доступа к файлу
	//4. Файл не существует


	//Удаление файла
	/*if(remove(path.c_str()) == 0)
		std::cout << "Файл \"" << path << "\" удален.\n";
	else
	   std::cout << "Ошибка удаления файла.\n";*/

	//1. Файл открыт другим приложением или объектом
	//2. Неправильный синтаксис указания пути к файлу
	//3. Нет доступа к файлу
	//4. Файл не существует

	//Task 1
std::cout << "Задача 1.\nВведите слово -> ";
	std::string word;
	std::getline(std::cin, word);
	if (statistic(word))
	std::cout << "Слово записано в файл.\n\n";
	else
		std::cout << "Ошибка выполнения функции.\n\n";

	return 0;
}

bool statistic(std::string str) {//Прототип
	std::ofstream out;
	std::string path = "words.txt";
	out.open(path, std::ios::app);
	if (out.is_open()) {
		out << str << ' ' << str.length() << '\n';
		out.close(); //До return
		return true;
	}
	out.close();
	return false;
}